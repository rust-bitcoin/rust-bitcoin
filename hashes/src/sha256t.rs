// SPDX-License-Identifier: CC0-1.0

//! SHA256t implementation (tagged SHA256).
//!

/// Macro used to define a newtype tagged hash.
///
/// This macro creates two types:
///
/// * a tag struct
/// * a hash wrapper
///
/// The syntax is:
///
/// ```
/// # use bitcoin_hashes::{sha256t_hash_newtype, HashEngine};
/// sha256t_hash_newtype! {
///     /// A foo hash.
///     // Direction works just like in case of hash_newtype! macro.
///     #[hash_newtype(forward)]
///     pub struct FooHash(_);
///
///     pub struct FooHashEngine(_) = hash_str("foo");
/// }
/// ```
///
/// The structs must be defined in this order - tag first, then hash type. `hash_str` marker
/// says the midstate should be generated by hashing the supplied string in a way described in
/// BIP-341. Alternatively, you can supply `hash_bytes` to hash raw bytes. If you have the midstate
/// already pre-computed and prefer **compiler** performance to readability you may use
/// `raw(MIDSTATE_BYTES, HASHED_BYTES_LENGTH)` instead.
///
/// Both visibility modifiers and attributes are optional and passed to inner structs (excluding
/// `#[hash_newtype(...)]`). The attributes suffer same compiler performance limitations as in
/// [`hash_newtype`] macro.
///
/// The macro accepts multiple inputs so you can define multiple hash newtypes in one macro call.
/// Just make sure to enter the structs in order `Tag0`, `Hash0`, `Tag1`, `Hash1`...
///
/// [`hash_newtype`]: crate::hash_newtype
#[macro_export]
macro_rules! sha256t_hash_newtype {
    ($(
        $(#[$($hash_attr:tt)*])* $hash_vis:vis struct $hash_name:ident($(#[$($field_attr:tt)*])* _);
        $(#[$($engine_attr:tt)*])* $engine_vis:vis struct $engine_name:ident(_) = $constructor:tt($($tag_value:tt)+);
    )+) => {
        $(
            $($crate::hash_newtype_known_attrs!(#[ $($hash_attr)* ]);)*

            #[cfg(feature = "bitcoin-io")]
            use $crate::HashEngine as _;

            $crate::hash_newtype_struct! {
                $hash_vis struct $hash_name($crate::sha256::Hash);

                $({ $($hash_attr)* })*
            }

            $crate::hex_fmt_impl!(<$hash_name as $crate::Hash>::DISPLAY_BACKWARD, 32, $hash_name);
            $crate::serde_impl!($hash_name, 32);
            $crate::borrow_slice_impl!($hash_name);

            impl $hash_name {
                /// Creates this wrapper type from the inner hash type.
                #[allow(unused)] // the user of macro may not need this
                pub fn from_raw_hash(inner: $crate::sha256::Hash) -> $hash_name {
                    $hash_name(inner)
                }

                /// Returns the inner hash (sha256, sh256d etc.).
                #[allow(unused)] // the user of macro may not need this
                pub fn to_raw_hash(self) -> $crate::sha256::Hash {
                    self.0
                }

                /// Returns a reference to the inner hash (sha256, sh256d etc.).
                #[allow(unused)] // the user of macro may not need this
                pub fn as_raw_hash(&self) -> &$crate::sha256::Hash {
                    &self.0
                }
            }

            impl $crate::_export::_core::convert::From<$crate::sha256::Hash> for $hash_name {
                fn from(inner: $crate::sha256::Hash) -> $hash_name {
                    // Due to rust 1.22 we have to use this instead of simple `Self(inner)`
                    Self { 0: inner }
                }
            }

            impl $crate::_export::_core::convert::From<$hash_name> for $crate::sha256::Hash {
                fn from(hashtype: $hash_name) -> $crate::sha256::Hash {
                    hashtype.0
                }
            }

            // FIXME: Feature gating is wrong, "schemars" needs "alloc" (because of string stuff).
            #[cfg(feature = "schemars")]
            impl $crate::schemars::JsonSchema for $hash_name {
                fn schema_name() -> String { $crate::_export::_core::stringify!($hash_name).to_string() }

                fn json_schema(gen: &mut $crate::schemars::gen::SchemaGenerator) -> $crate::schemars::schema::Schema {
                    let mut schema: $crate::schemars::schema::SchemaObject = <String>::json_schema(gen).into();
                    schema.string = Some(Box::new($crate::schemars::schema::StringValidation {
                        max_length: Some(32 * 2),
                        min_length: Some(32 * 2),
                        pattern: Some("[0-9a-fA-F]+".to_owned()),
                    }));
                    schema.into()
                }
            }

            impl $crate::Hash for $hash_name {
                type Engine = $engine_name;
                type Bytes = <$crate::sha256::Hash as $crate::Hash>::Bytes;

                const LEN: usize = 32;
                const DISPLAY_BACKWARD: bool = $crate::hash_newtype_get_direction!($crate::sha256::Hash, $(#[$($hash_attr)*])*);

                fn engine() -> Self::Engine { Self::Engine::default() }

                fn from_engine(e: Self::Engine) -> Self {
                    Self::from($crate::sha256::Hash::from_engine(e.0))
                }

                #[inline]
                fn from_slice(sl: &[u8]) -> $crate::_export::_core::result::Result<$hash_name, $crate::FromSliceError> {
                    Ok($hash_name($crate::sha256::Hash::from_slice(sl)?))
                }

                #[inline]
                fn from_byte_array(bytes: Self::Bytes) -> Self {
                    $hash_name($crate::sha256::Hash::from_byte_array(bytes))
                }

                #[inline]
                fn to_byte_array(self) -> Self::Bytes {
                    self.0.to_byte_array()
                }

                #[inline]
                fn as_byte_array(&self) -> &Self::Bytes {
                    self.0.as_byte_array()
                }

                #[inline]
                fn all_zeros() -> Self {
                    let zeros = <$crate::sha256::Hash>::all_zeros();
                    $hash_name(zeros)
                }
            }

            impl $crate::_export::_core::str::FromStr for $hash_name {
                type Err = $crate::hex::HexToArrayError;
                fn from_str(s: &str) -> $crate::_export::_core::result::Result<$hash_name, Self::Err> {
                    use $crate::{Hash, hex::FromHex};

                    let mut bytes = <[u8; 32]>::from_hex(s)?;
                    if <Self as $crate::Hash>::DISPLAY_BACKWARD {
                        bytes.reverse();
                    };
                    Ok($hash_name($crate::sha256::Hash::from_byte_array(bytes)))
                }
            }

            impl $crate::_export::_core::convert::AsRef<[u8; 32]> for $hash_name {
                fn as_ref(&self) -> &[u8; 32] {
                    AsRef::<[u8; 32]>::as_ref(&self.0)
                }
            }

            impl<I: $crate::_export::_core::slice::SliceIndex<[u8]>> $crate::_export::_core::ops::Index<I> for $hash_name {
                type Output = I::Output;

                #[inline]
                fn index(&self, index: I) -> &Self::Output {
                    &self.0[index]
                }
            }

            /// Engine to compute a tagged SHA256 hash.
            #[derive(Clone)]
            $engine_vis struct $engine_name($crate::sha256::HashEngine);

            impl Default for $engine_name {
                fn default() -> Self {
                    const MIDSTATE: ($crate::sha256::Midstate, usize) = $crate::sha256t_hash_newtype_tag_constructor!($constructor, $($tag_value)+);
                    #[allow(unused)]
                    const _LENGTH_CHECK: () = [(); 1][MIDSTATE.1 % 64];

                    let inner = $crate::sha256::HashEngine::from_midstate(MIDSTATE.0, MIDSTATE.1);
                    $engine_name(inner)
                }
            }

            impl $crate::HashEngine for $engine_name {
                type MidState = $crate::sha256::Midstate;

                #[inline]
                fn midstate(&self) -> $crate::sha256::Midstate { self.0.midstate() }

                const BLOCK_SIZE: usize = $crate::sha256::BLOCK_SIZE;

                #[inline]
                fn n_bytes_hashed(&self) -> usize { self.0.n_bytes_hashed() }

                #[inline]
                fn input(&mut self, data: &[u8]) { self.0.input(data) }
            }

            #[cfg(feature = "bitcoin-io")]
            bitcoin_io::impl_write!(
                $engine_name,
                |us: &mut $engine_name, buf| {
                    us.input(buf);
                    Ok(buf.len())
                },
                |_us| { Ok(()) }
            );
        )+
    }
}

// Workaround macros being unavailable in attributes.
#[doc(hidden)]
#[macro_export]
macro_rules! sha256t_hash_newtype_tag {
    ($vis:vis, $tag:ident, $name:expr, $(#[$($attr:meta)*])*) => {
        #[doc = "The tag used for [`"]
        #[doc = $name]
        #[doc = "`]\n\n"]
        $(#[$($attr)*])*
        #[derive(Copy, Clone, PartialEq, Eq, Default, PartialOrd, Ord, Hash)]
        $vis struct $tag;
    };
}

#[doc(hidden)]
#[macro_export]
macro_rules! sha256t_hash_newtype_tag_constructor {
    (hash_str, $value:expr) => {
        ($crate::sha256::Midstate::hash_tag($value.as_bytes()), 64)
    };
    (hash_bytes, $value:expr) => {
        ($crate::sha256::Midstate::hash_tag($value), 64)
    };
    (raw, $bytes:expr, $len:expr) => {
        ($crate::sha256::Midstate::from_byte_array($bytes), $len)
    };
}

#[cfg(test)]
mod tests {
    #[cfg(feature = "alloc")]
    use crate::Hash;

    const TEST_MIDSTATE: [u8; 32] = [
        156, 224, 228, 230, 124, 17, 108, 57, 56, 179, 202, 242, 195, 15, 80, 137, 211, 243, 147,
        108, 71, 99, 110, 96, 125, 179, 62, 234, 221, 198, 240, 201,
    ];

    sha256t_hash_newtype! {
        /// A test hash.
        #[hash_newtype(backward)]
        struct NewTypeHash(_);

        struct NewTypeHashEngine(_) = raw(TEST_MIDSTATE, 64);
    }

    #[test]
    #[cfg(feature = "alloc")]
    fn test_sha256t() {
        assert_eq!(
            NewTypeHash::hash(&[0]).to_string(),
            "29589d5122ec666ab5b4695070b6debc63881a4f85d88d93ddc90078038213ed"
        );
    }

    sha256t_hash_newtype! {
        /// A test hash.
        #[hash_newtype(backward)]
        struct FooHash(_);

        struct FooHashEngine(_) = hash_str("foo");
    }

    #[test]
    #[cfg(feature = "alloc")]
    fn tagged_hash() {
        assert_eq!(
            FooHash::hash(&[0]).to_string(),
            "cee837ec9192cfdb0e5762e9dd1881e9b4147fce76aea79f3b34cbc765935da6",
        );
    }
}
