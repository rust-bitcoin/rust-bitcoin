// SPDX-License-Identifier: CC0-1.0

//! SHA256t implementation (tagged SHA256).

/// Re-export everything from `chf::sha256t`.
pub use chf::sha256t::{Engine, Hash, Tag};

/// Macro used to define a newtype tagged hash.
///
/// This macro creates two types:
///
/// * a tag struct
/// * a hash wrapper
///
/// The syntax is:
///
/// ```
/// # use bitcoin_hashes::{sha256t_hash_newtype, Tag, HashEngine};
/// sha256t_hash_newtype! {
///     /// Optional documentation details here.
///     /// Summary is always generated.
///     pub struct FooTag = hash_str("foo");
///
///     /// A foo hash.
///     pub struct FooHash(_);
/// }
/// ```
///
/// The structs must be defined in this order - tag first, then hash type. `hash_str` marker
/// says the midstate should be generated by hashing the supplied string in a way described in
/// BIP-341. Alternatively, you can supply `hash_bytes` to hash raw bytes. If you have the midstate
/// already pre-computed and prefer **compiler** performance to readability you may use
/// `raw(MIDSTATE_BYTES, HASHED_BYTES_LENGTH)` instead.
///
/// Both visibility modifiers and attributes are optional and passed to inner structs (excluding
/// `#[hash_newtype(...)]`). The attributes suffer same compiler performance limitations as in
/// [`hash_newtype`] macro.
///
/// The macro accepts multiple inputs so you can define multiple hash newtypes in one macro call.
/// Just make sure to enter the structs in order `Tag0`, `Hash0`, `Tag1`, `Hash1`...
///
/// [`hash_newtype`]: crate::hash_newtype

#[doc(hidden)]
#[macro_export]
macro_rules! sha256t_hash_newtype {
    ($(
        $(#[$($tag_attrs:tt)*])* $tag_vis:vis struct $tag:ident = $constructor:tt($($tag_value:tt)+);
        $(#[$($newtype_attrs:tt)*])* $newtype_vis:vis struct $newtype:ident(_);
    )+) => {
        $(
        $crate::sha256t_hash_newtype_tag!($tag_vis, $tag, stringify!($newtype), $(#[$($tag_attrs)*])*);

        impl $crate::sha256t::Tag for $tag {
            #[inline]
            fn engine() -> $crate::sha256t::Engine<Self> {
                use $crate::HashEngine;

                const MIDSTATE: ($crate::sha256::Midstate, usize) = $crate::tagged_midstate!($constructor, $($tag_value)+);
                #[allow(unused)]
                const _LENGTH_CHECK: () = [(); 1][MIDSTATE.1 % 64];

                $crate::sha256t::Engine::from_midstate(MIDSTATE.0, MIDSTATE.1)
            }
        }

        $crate::hash_newtype_struct! {
            $newtype_vis struct $newtype($crate::sha256t::Hash<$tag>);

            $({ $($newtype_attrs)* })*
        }

        $crate::hex_fmt_impl!($newtype);
        $crate::serde_impl!($newtype);
        $crate::borrow_slice_impl!($newtype);

        #[allow(unused)] // Not all functions are used by all hash types.
        impl $newtype {
            const DISPLAY_BACKWARD: bool = false; // Never display backwards for tagged hashes.

            /// Creates this wrapper type from the inner hash type.
            pub fn from_raw_hash(inner: $crate::sha256t::Hash<$tag>) -> Self { Self(inner) }

            /// Returns the inner hash (sha256, sh256d etc.).
            pub fn to_raw_hash(self) -> $crate::sha256t::Hash<$tag> { self.0 }

            /// Returns a reference to the inner hash (sha256, sh256d etc.).
            pub fn as_raw_hash(&self) -> &$crate::sha256t::Hash<$tag> { &self.0 }

            /// Length of the hash, in bytes.
            pub const LEN: usize = 32;

            /// Creates a default hash engine, adds `bytes` to it, then finalizes the engine.
            ///
            /// # Returns
            ///
            /// The digest created by hashing `bytes` with engine's hashing algorithm.
            #[allow(clippy::self_named_constructors)] // `hash` is a verb but `Hash` is a noun.
            pub fn hash(bytes: &[u8]) -> Self {
                let inner = $crate::sha256t::Hash::<$tag>::hash(bytes);
                Self(inner)
            }

            /// Returns a hash engine that is ready to be used for data.
            pub fn engine() -> $crate::sha256t::Engine<$tag> { $tag::engine() }

            /// Creates a `Hash` from an `engine`.
            ///
            /// This is equivalent to calling `Hash::from_byte_array(engine.finalize())`.
            pub fn from_engine(engine: $crate::sha256t::Engine<$tag>) -> Self {
                let inner = $crate::sha256t::Hash::<$tag>::from_engine(engine);
                Self(inner)
            }

            /// Zero cost conversion between a fixed length byte array shared reference and
            /// a shared reference to this Hash type.
            pub fn from_bytes_ref(bytes: &[u8; 32]) -> &Self {
                // Safety: Sound because Self is #[repr(transparent)] containing [u8; Self::LEN]
                unsafe { &*(bytes as *const _ as *const Self) }
            }

            /// Zero cost conversion between a fixed length byte array exclusive reference and
            /// an exclusive reference to this Hash type.
            pub fn from_bytes_mut(bytes: &mut [u8; 32]) -> &mut Self {
                // Safety: Sound because Self is #[repr(transparent)] containing [u8; 32]
                unsafe { &mut *(bytes as *mut _ as *mut Self) }
            }

            /// Copies a byte slice into a hash object.
            pub fn from_slice(sl: &[u8]) -> Result<Self, $crate::FromSliceError> {
                let inner = $crate::sha256t::Hash::<$tag>::from_slice(sl)?;
                Ok(Self(inner))
            }

            /// Constructs a hash from the underlying byte array.
            pub fn from_byte_array(bytes: [u8; 32]) -> Self {
                let inner = $crate::sha256t::Hash::<$tag>::from_byte_array(bytes);
                Self(inner)
            }

            /// Returns the underlying byte array.
            pub fn to_byte_array(self) -> [u8; 32] { self.0.to_byte_array() }

            /// Returns a reference to the underlying byte array.
            pub fn as_byte_array(&self) -> &[u8; 32] { self.0.as_byte_array() }

            /// Returns an all zero hash.
            ///
            /// An all zeros hash is a made up construct because there is not a known input that can
            /// create it, however it is used in various places in Bitcoin e.g., the Bitcoin genesis
            /// block's previous blockhash and the coinbase transaction's outpoint txid.
            pub fn all_zeros() -> Self {
                let inner = $crate::sha256t::Hash::<$tag>::all_zeros();
                Self(inner)
            }
        }

        impl core::str::FromStr for $newtype {
            type Err = hex::HexToArrayError;

            fn from_str(s: &str) -> core::result::Result<$newtype, Self::Err> {
                let inner = $crate::sha256t::Hash::<$tag>::from_str(s)?;
                Ok(Self(inner))
            }
        }

        impl core::convert::AsRef<[u8; 32]> for $newtype {
            #[inline]
            fn as_ref(&self) -> &[u8; 32] { AsRef::<[u8; 32]>::as_ref(&self.0) }
        }

        impl<I: core::slice::SliceIndex<[u8]>> core::ops::Index<I> for $newtype {
            type Output = I::Output;
            #[inline]
            fn index(&self, index: I) -> &Self::Output { &self.0[index] }
        }

        impl core::fmt::Debug for $newtype {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{:?}", self.0)
            }
        }

        )+
    };
}

// Workaround macros being unavailable in attributes.
#[doc(hidden)]
#[macro_export]
macro_rules! sha256t_hash_newtype_tag {
    ($vis:vis, $tag:ident, $name:expr, $(#[$($attr:meta)*])*) => {
        #[doc = "The tag used for [`"]
        #[doc = $name]
        #[doc = "`]\n\n"]
        $(#[$($attr)*])*
        #[derive(Copy, Clone, PartialEq, Eq, Default, PartialOrd, Ord, Hash)]
        $vis struct $tag;
    };
}

/// Creates a const midstate used to instantiate a SHA256 pre-tagged engine.
///
/// Requires `hashes::sha256` to be in scope.
#[doc(hidden)]
#[macro_export]
macro_rules! tagged_midstate {
    (hash_str, $value:expr) => {
        ($crate::sha256::Midstate::hash_tag($value.as_bytes()), 64)
    };
    (hash_bytes, $value:expr) => {
        ($crate::sha256::Midstate::hash_tag($value), 64)
    };
    (raw, $bytes:expr, $len:expr) => {
        ($crate::sha256::Midstate::from_byte_array($bytes), $len)
    };
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::HashEngine;

    const TEST_MIDSTATE: [u8; 32] = [
        156, 224, 228, 230, 124, 17, 108, 57, 56, 179, 202, 242, 195, 15, 80, 137, 211, 243, 147,
        108, 71, 99, 110, 96, 125, 179, 62, 234, 221, 198, 240, 201,
    ];

    // The digest created by sha256 hashing `&[0]` starting with `TEST_MIDSTATE`.
    #[cfg(feature = "alloc")]
    const HASH_ZERO: &str = "ed1382037800c9dd938dd8854f1a8863bcdeb6705069b4b56a66ec22519d5829";

    // We also provide a macro to create the tag and the hash type.
    sha256t_hash_newtype! {
        /// Test detailed explanation.
        struct NewTag = raw(TEST_MIDSTATE, 64);

        /// A test hash.
        struct NewTaggedHash(_);
    }

    #[test]
    #[cfg(feature = "alloc")]
    fn hash_engine() {
        let mut engine = Engine::<NewTag>::new();
        engine.input(&[0]);
        let digest = engine.finalize();
        let hash = Hash::<NewTag>::from_byte_array(digest);

        let got = hash.to_string();
        assert_eq!(got, HASH_ZERO);
    }

    #[test]
    #[cfg(feature = "alloc")]
    fn hash_type() {
        let got = Hash::<NewTag>::hash(&[0]).to_string();
        assert_eq!(got, HASH_ZERO);
    }
}
